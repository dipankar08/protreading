"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitX = exports.replaceAll = exports.regexMatch = exports.captureContext = exports.assert = exports.callNetwork = exports.sleepMS = exports.sleep = void 0;
var util = require('util');
var chalk = require("chalk");
var sync_request_1 = require("sync-request");
var namedRegexp = require("named-js-regexp");
// helper
function sleep(s) {
    return new Promise(function (resolve) { return setTimeout(resolve, s * 1000); });
}
exports.sleep = sleep;
function sleepMS(s) {
    return new Promise(function (resolve) { return setTimeout(resolve, s); });
}
exports.sleepMS = sleepMS;
function callNetwork(type, url, data) {
    var res = sync_request_1.default(type, url, data);
    // We also needs to keep track status code
    if (res.statusCode != 200) {
        throw Error("[callNetwork] Issue with network request as <" + res.statusCode + "> for url:" + url + ", data:<" + data + " >");
    }
    try {
        return res.getBody('utf8');
    }
    catch (e) {
        return e.toString();
    }
}
exports.callNetwork = callNetwork;
function assert(cond, error) {
    if (!cond) {
        throw Error(error);
    }
}
exports.assert = assert;
function captureContext(template, string, context) {
    var matched;
    try {
        matched = new namedRegexp(template).exec(string);
    }
    catch (e) {
        return false;
    }
    if (matched == null) {
        return false;
    }
    // Try Capture Context which will be used lateron.
    if (matched.groups() != null && Object.keys(matched.groups()).length > 0) {
        Object.assign(context, matched.groups());
        console.log(chalk.blue(util.format('[INFO] Context updated: now %s', JSON.stringify(context))));
        return true;
    }
    return false;
}
exports.captureContext = captureContext;
function regexMatch(reg, str) {
    var matched;
    try {
        matched = new namedRegexp(reg).exec(str);
    }
    catch (e) {
        console.log("[regexMatch] Invalid regex: < " + reg + " >");
        return false;
    }
    if (matched == null) {
        return false;
    }
    return matched;
}
exports.regexMatch = regexMatch;
// JS default is not works for replace all.
// NOT WORKING
function replaceAll(str, find, replace) {
    return str.replace(new RegExp(find, 'g'), replace);
}
exports.replaceAll = replaceAll;
// SplitX allows to split around a character where you can mark as escape character if needed.abs
// NOT WORKING,.
function splitX(str, dilim) {
    var data = str.match(/(\\.|[^,])+/g);
    if (data == null) {
        return [];
    }
    // return data.map(x => replaceAll(x, "\\\\,", ",").trim())
    return data.map(function (x) { return x.replace("\\\\,", ",").trim(); });
}
exports.splitX = splitX;
//# sourceMappingURL=utils.js.map