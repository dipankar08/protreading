{"version":3,"file":"micromustache.js","sources":["../src/topath.ts","../src/get.ts","../src/renderer.ts","../src/tokenize.ts","../src/compile.ts","../src/render.ts"],"sourcesContent":["export type PropNames = string[]\n\n/**\n * The number of different varNames that will be cached.\n * If a varName is cached, the actual parsing algorithm will not be called\n * which significantly improves performance.\n * However, this cache is size-limited to prevent degrading the user's software\n * over a period of time.\n * If the cache is full, we start removing older varNames one at a time.\n */\nconst cacheSize = 100\nconst quoteChars = '\\'\"`'\n\n/**\n * @ignore\n */\nexport class Cache<T> {\n  private map: {\n    [varName: string]: T\n  }\n\n  private cachedKeys: string[]\n  private oldestIndex: number\n\n  constructor(private size: number) {\n    this.reset()\n  }\n\n  public reset() {\n    this.oldestIndex = 0\n    this.map = {}\n    this.cachedKeys = new Array(this.size)\n  }\n\n  public get(key: string): T {\n    return this.map[key]\n  }\n\n  public set(key: string, value: T) {\n    this.map[key] = value\n    const oldestKey = this.cachedKeys[this.oldestIndex]\n    if (oldestKey !== undefined) {\n      delete this.map[oldestKey]\n    }\n    this.cachedKeys[this.oldestIndex] = key\n    this.oldestIndex++\n    this.oldestIndex %= this.size\n  }\n}\n\nconst cache = new Cache<PropNames>(cacheSize)\n\n/**\n * Removes the quotes from a string and returns it.\n * @param propName an string with quotations\n * @throws `SyntaxError` if the quotation symbols don't match or one is missing\n * @returns the input with its quotes removed\n */\nfunction propBetweenBrackets(propName: string): string {\n  // in our algorithms key is always a string and never only a string of spaces\n  const firstChar = propName.charAt(0)\n  const lastChar = propName.substr(-1)\n  if (quoteChars.includes(firstChar) || quoteChars.includes(lastChar)) {\n    if (propName.length < 2 || firstChar !== lastChar) {\n      throw new SyntaxError('Mismatching string quotation: ' + propName)\n    }\n    return propName.substring(1, propName.length - 1)\n  }\n\n  if (propName.includes('[')) {\n    throw new SyntaxError('Missing ] in varName ' + propName)\n  }\n\n  // Normalize leading plus from numerical indices\n  if (firstChar === '+') {\n    return propName.substr(1)\n  }\n\n  return propName\n}\n\nfunction pushPropName(propNames: string[], propName: string, preDot: boolean) {\n  let pName = propName.trim()\n  if (pName === '') {\n    return propNames\n  }\n\n  if (pName.startsWith('.')) {\n    if (preDot) {\n      pName = pName.substr(1).trim()\n      if (pName === '') {\n        return propNames\n      }\n    } else {\n      throw new SyntaxError('Unexpected . at the start of \"' + propName + '\"')\n    }\n  } else if (preDot) {\n    throw new SyntaxError('Missing . at the start of \"' + propName + '\"')\n  }\n\n  if (pName.endsWith('.')) {\n    throw new SyntaxError('Unexpected \".\" at the end of \"' + propName + '\"')\n  }\n\n  const propNameParts = pName.split('.')\n  for (const propNamePart of propNameParts) {\n    const trimmedPropName = propNamePart.trim()\n    if (trimmedPropName === '') {\n      throw new SyntaxError('Empty prop name when parsing \"' + propName + '\"')\n    }\n    propNames.push(trimmedPropName)\n  }\n\n  return propNames\n}\n\n/**\n * Breaks a variable name to an array of strings that can be used to get a\n * particular value from an object\n * @param varName - the variable name as it occurs in the template.\n * For example `a[\"b\"].c`\n * @throws `TypeError` if the varName is not a string\n * @throws `SyntaxError` if the varName syntax has a problem\n * @returns - an array of property names that can be used to get a particular\n * value.\n * For example `['a', 'b', 'c']`\n */\nexport function toPath(varName: string): PropNames {\n  if (typeof varName !== 'string') {\n    throw new TypeError('Expected string but Got ' + varName)\n  }\n\n  let openBracketIndex: number\n  let closeBracketIndex: number = 0\n  let beforeBracket: string\n  let propName: string\n  let preDot = false\n  const propNames: PropNames = []\n\n  for (\n    let currentIndex = 0;\n    currentIndex < varName.length;\n    currentIndex = closeBracketIndex\n  ) {\n    openBracketIndex = varName.indexOf('[', currentIndex)\n    if (openBracketIndex === -1) {\n      break\n    }\n\n    closeBracketIndex = varName.indexOf(']', openBracketIndex)\n    if (closeBracketIndex === -1) {\n      throw new SyntaxError('Missing ] in varName ' + varName)\n    }\n\n    propName = varName.substring(openBracketIndex + 1, closeBracketIndex).trim()\n\n    if (propName.length === 0) {\n      throw new SyntaxError('Unexpected token ]')\n    }\n\n    closeBracketIndex++\n    beforeBracket = varName.substring(currentIndex, openBracketIndex)\n    pushPropName(propNames, beforeBracket, preDot)\n\n    propNames.push(propBetweenBrackets(propName))\n    preDot = true\n  }\n\n  const rest = varName.substring(closeBracketIndex)\n  return pushPropName(propNames, rest, preDot)\n}\n\n/**\n * This is just a faster version of `toPath()`\n */\nfunction toPathCached(varName: string): PropNames {\n  let result = cache.get(varName)\n  if (result === undefined) {\n    result = toPath(varName)\n    cache.set(varName, result)\n  }\n  return result\n}\n\ntoPath.cached = toPathCached\n","import { toPath, PropNames } from './topath'\n\n// tslint:disable-next-line ban-types\nexport type Scope = {} | Function\n\n/**\n * Checks if the provided value can be used as a scope, that is a non-null\n * object or a function.\n * @param val the value that is supposed to be tested\n */\nfunction isValidScope(val: any): val is Scope {\n  if (val) {\n    // At this point `null` is filtered out\n    const type = typeof val\n    return type === 'object' || type === 'function'\n  }\n  return false\n}\n\n/**\n * Similar to lodash `_.get()`\n *\n * Differences with JavaScript:\n * No support for keys that include `[` or `]`.\n * No support for keys that include `'` or `\"` or `.\n * `foo[bar]` is allowed while JavaScript treats `bar` as a variable and tries\n * to lookup its value or throws a `ReferenceError` if there is no variable\n * called `bar`.\n * If it cannot find a value in the specified path, it may return undefined or\n * throw an error depending on the value of the `propExists` param.\n * @param scope an object to resolve value from\n * @param varNameOrPropNames the variable name string or an array of property\n * names (as returned by `toPath()`)\n * @param propExists claiming that the varName is exists in the scope.\n * It defaults to false which means we don't throw an error (like Mustachejs).\n * @throws `SyntaxError` if the varName string cannot be parsed\n * @throws `ReferenceError` if the scope does not contain the requested key\n * but the `propExists` is set to a truthy value\n * @returns the value or undefined. If path or scope are undefined or scope is\n * null the result is always undefined.\n */\nexport function get(\n  scope: Scope,\n  varNameOrPropNames: PropNames | string,\n  propExists?: boolean\n): any {\n  const propNames = Array.isArray(varNameOrPropNames)\n    ? varNameOrPropNames\n    : toPath.cached(varNameOrPropNames)\n\n  let currentScope = scope\n  for (const propName of propNames) {\n    if (isValidScope(currentScope)) {\n      // @ts-ignore\n      currentScope = currentScope[propName]\n    } else if (propExists) {\n      throw new ReferenceError(\n        propName +\n          ' is not defined in the scope (' +\n          scope +\n          '). Parsed path: ' +\n          propNames\n      )\n    } else {\n      return\n    }\n  }\n  return currentScope\n}\n","import { Scope, get } from './get'\nimport { PropNames, toPath } from './topath'\nimport { ITokens } from './tokenize'\n\n/**\n * The options passed to Renderer's constructor\n */\nexport interface IRendererOptions {\n  /**\n   * When set to a truthy value, rendering literally puts a 'null' or\n   * 'undefined' for values that are `null` or `undefined`.\n   * By default it swallows those values to be compatible with Mustache.\n   */\n  readonly explicit?: boolean\n  /**\n   * When set to a truthy value, we throw a ReferenceError for invalid varNames.\n   * Invalid varNames are the ones that do not exist in the scope.\n   * In that case the value for the varNames will be assumed an empty string.\n   * By default we throw a ReferenceError to be compatible with how JavaScript\n   * threats such invalid reference.\n   * If a value does not exist in the scope, two things can happen:\n   * - if `propsExist` is truthy, the value will be assumed empty string\n   * - if `propsExist` is falsy, a ReferenceError will be thrown\n   */\n  readonly propsExist?: boolean\n  /** when set to a truthy value, validates the variable names */\n  readonly validateVarNames?: boolean\n}\n\nconst defaultRendererOptions: IRendererOptions = {}\n\n/**\n * The callback for resolving a value (synchronous)\n * @param scope the scope object that was passed to .render() function\n * @param path variable name before being parsed.\n * @example a template that is `Hi {{a.b.c}}!` leads to `'a.b.c'` as path\n * @returns the value to be interpolated.\n */\nexport type ResolveFn = (varName: string, scope?: Scope) => any\n\n/**\n * Same as `ResolveFn` but for asynchronous functions\n */\nexport type ResolveFnAsync = (varName: string, scope?: Scope) => Promise<any>\n\n/**\n * This class does the heavy lifting of interpolation (putting the actual values\n * in the template).\n * This is created by the `.compile()` method and is used under the hood by\n * `.render()`, `renderFn()` and `renderFnAsync()` functions.\n */\nexport class Renderer {\n  /**\n   * Another cache that holds the parsed values for `toPath()` one per varName\n   */\n  private toPathCache: PropNames[]\n\n  /**\n   * Creates a new Renderer instance. This is called internally by the compiler.\n   * @param tokens - the result of the `.tokenize()` function\n   * @param options - some options for customizing the rendering process\n   * @throws `TypeError` if the token is invalid\n   */\n  constructor(\n    private readonly tokens: ITokens,\n    private readonly options: IRendererOptions = defaultRendererOptions\n  ) {\n    if (\n      tokens === null ||\n      typeof tokens !== 'object' ||\n      !Array.isArray(tokens.strings) ||\n      !Array.isArray(tokens.varNames) ||\n      tokens.strings.length !== tokens.varNames.length + 1\n    ) {\n      throw new TypeError('Invalid tokens object ' + tokens)\n    }\n    if (options.validateVarNames) {\n      // trying to initialize toPathCache parses them which is also validation\n      this.cacheParsedPaths()\n    }\n  }\n\n  /**\n   * This function is called internally for filling in the `toPathCache` cache.\n   * If the `validateVarNames` option for the constructor is set to a truthy\n   * value, this function is called immediately which leads to a validation as\n   * well because it throws an error if it cannot parse variable names.\n   */\n  private cacheParsedPaths() {\n    const { varNames } = this.tokens\n    if (this.toPathCache === undefined) {\n      this.toPathCache = new Array(varNames.length)\n      for (let i = 0; i < varNames.length; i++) {\n        this.toPathCache[i] = toPath.cached(varNames[i])\n      }\n    }\n  }\n\n  /**\n   * Replaces every {{varName}} inside the template with values from the scope\n   * parameter.\n   *\n   * @param template The template containing one or more {{varName}} as\n   * placeholders for values from the `scope` parameter.\n   * @param scope An object containing values for variable names from the the\n   * template. If it's omitted, we default to an empty object.\n   */\n  public render = (scope: Scope = {}): string => {\n    const { varNames } = this.tokens\n    const { length } = varNames\n    this.cacheParsedPaths()\n    const values = new Array(length)\n    for (let i = 0; i < length; i++) {\n      values[i] = get(scope, this.toPathCache[i], this.options.propsExist)\n    }\n    return this.stringify(values)\n  }\n\n  /**\n   * Same as [[render]] but accepts a resolver function which will be\n   * responsible for returning a value for every varName.\n   */\n  public renderFn = (resolveFn: ResolveFn, scope: Scope = {}): string => {\n    const values = this.resolveVarNames(resolveFn, scope)\n    return this.stringify(values)\n  }\n\n  /**\n   * Same as [[render]] but accepts a resolver function which will be responsible\n   * for returning promise that resolves to a value for every varName.\n   */\n  public renderFnAsync = (\n    resolveFnAsync: ResolveFnAsync,\n    scope: Scope = {}\n  ): Promise<string> => {\n    return Promise.all(this.resolveVarNames(resolveFnAsync, scope)).then(\n      values => this.stringify(values)\n    )\n  }\n\n  private resolveVarNames(resolveFn: ResolveFn, scope: Scope = {}): any[] {\n    const { varNames } = this.tokens\n    if (typeof resolveFn !== 'function') {\n      throw new TypeError('Expected a resolver function but got ' + resolveFn)\n    }\n\n    const { length } = varNames\n    const values = new Array(length)\n    for (let i = 0; i < length; i++) {\n      values[i] = resolveFn.call(null, varNames[i], scope)\n    }\n    return values\n  }\n\n  /**\n   * Puts the resolved `values` into the rest of the template (`strings`) and\n   * returns the final result that'll be returned from `render()`, `renderFn()`\n   * and `renderFnAsync()` functions.\n   */\n  private stringify(values: any[]): string {\n    const { strings } = this.tokens\n    const { explicit } = this.options\n    let ret = ''\n    const { length } = values\n    for (let i = 0; i < length; i++) {\n      ret += strings[i]\n      const value = values[i]\n      if (explicit || (value !== null && value !== undefined)) {\n        ret += value\n      }\n    }\n\n    ret += strings[length]\n    return ret\n  }\n}\n","export interface ITokens {\n  /** An array of constant strings */\n  readonly strings: string[]\n  /** An array of variable names */\n  readonly varNames: string[]\n}\n\n/**\n * An array of two strings specifying the opening and closing tags that mark\n * the start and end of a variable name in the template.\n * It defaults to `['{{', '}}']`\n */\nexport type TokenizeOptions = [string, string]\nconst defaultTokenizeOptions: TokenizeOptions = ['{{', '}}']\n\n/**\n * Parse a template and returns the tokens in an object.\n *\n * @throws `TypeError` if there's an issue with its inputs\n * @throws `SyntaxError` if there's an issue with the template\n *\n * @param template the template\n * @param openSym the string that marks the start of a variable name\n * @param closeSym the string that marks the start of a variable name\n * @returns the resulting tokens as an object that has strings and variable names\n */\nexport function tokenize(\n  template: string,\n  options: TokenizeOptions = defaultTokenizeOptions\n): ITokens {\n  if (!Array.isArray(options)) {\n    throw Error(\n      `Tags should be an array. Got ${options}`\n    )\n  }\n\n  if (options.length !== 2) {\n    throw new TypeError(`The tags array should contain exactly two elements, got ${options.length}`)\n  }\n\n  const [openSym, closeSym] = options\n  if (typeof openSym !== 'string' || openSym.length === 0) {\n    throw new TypeError(`openSym should be a non-empty string. Got ${openSym}`)\n  }\n  if (typeof closeSym !== 'string' || closeSym.length === 0) {\n    throw new TypeError(`closeSym should be a non-empty string. Got ${closeSym}`)\n  }\n  \n  const maxVarNameLength = 1000\n\n  if (\n    typeof openSym !== 'string' ||\n    typeof closeSym !== 'string' ||\n    openSym.length === 0 ||\n    closeSym.length === 0 ||\n    openSym === closeSym\n  ) {\n    throw new TypeError(\n      'The tags array should have two distinct non-empty strings. Got ' +\n        options.join()\n    )\n  }\n\n  const openSymLen = openSym.length\n  const closeSymLen = closeSym.length\n\n  let openIndex: number\n  let closeIndex: number = 0\n  let varName: string\n  const strings: string[] = []\n  const varNames: string[] = []\n  let currentIndex = 0\n\n  while (currentIndex < template.length) {\n    openIndex = template.indexOf(openSym, currentIndex)\n    if (openIndex === -1) {\n      break\n    }\n\n    closeIndex = template.indexOf(closeSym, openIndex)\n    if (closeIndex === -1) {\n      throw new SyntaxError(\n        'Missing \"' + closeSym + '\" in the template expression ' + template\n      )\n    }\n\n    const varNameStartIndex = openIndex + openSymLen\n    const varNameLength = closeIndex - varNameStartIndex\n    if (varNameLength > maxVarNameLength) {\n      throw new SyntaxError(\n        'Variable name cannot be longer than ' +\n          maxVarNameLength +\n          ' but at position ' +\n          openIndex +\n          ' it is \"' +\n          varNameLength +\n          '\"'\n      )\n    }\n\n    varName = template.substr(varNameStartIndex, varNameLength).trim()\n\n    if (varName.length === 0) {\n      throw new SyntaxError(\n        'Unexpected \"' + closeSym + '\" tag found at position ' + openIndex\n      )\n    }\n\n    if (varName.length >= maxVarNameLength) {\n      throw new SyntaxError(`The variable name is longer than expected. Max: ${maxVarNameLength}, Got: ${varName.length}`)\n    }\n\n    if (varName.includes(openSym)) {\n      throw new SyntaxError(\n        'Variable names cannot have \"' +\n          openSym +\n          '\". But at position ' +\n          openIndex +\n          ' got \"' +\n          varName +\n          '\"'\n      )\n    }\n\n    varNames.push(varName)\n\n    closeIndex += closeSymLen\n    strings.push(template.substring(currentIndex, openIndex))\n    currentIndex = closeIndex\n  }\n\n  strings.push(template.substring(closeIndex))\n\n  return { strings, varNames }\n}\n","import { Renderer, IRendererOptions } from './renderer'\nimport { tokenize, TokenizeOptions } from './tokenize'\n\n/**\n * The options that customize the tokenization of the template and the renderer\n * object that is returned\n */\nexport interface ICompileOptions extends IRendererOptions {\n  /**\n   * The string symbols that mark the opening and closing of a variable name in\n   * the template.\n   * It defaults to `['{{', '}}']`\n   */\n  readonly tags?: TokenizeOptions\n}\n\nconst defaultCompileOptions: ICompileOptions = {}\n\n/**\n * Compiles a template and returns an object with functions that render it.\n * Compilation makes repeated render calls more optimized by parsing the\n * template only once and reusing the results.\n * As a result, rendering gets 3-5x faster.\n * Caching is stored in the resulting object, so if you free up all the\n * references to that object, the caches will be garbage collected.\n *\n * @param template same as the template parameter to .render()\n * @param options some options for customizing the compilation\n * @throws `TypeError` if the template is not a string\n * @throws `TypeError` if the options is set but is not an object\n * @throws any error that [[tokenize]] or [[Renderer.constructor]] may throw\n * @returns an object with some methods that can do the actual rendering\n */\nexport function compile(\n  template: string,\n  options: ICompileOptions = defaultCompileOptions\n): Renderer {\n  if (typeof template !== 'string') {\n    throw new TypeError(\n      'The template parameter must be a string. Got ' + template\n    )\n  }\n\n  if (options === null || typeof options !== 'object') {\n    throw new TypeError(\n      'The compiler options should be an object. Got ' + options\n    )\n  }\n\n  const tokens = tokenize(template, options.tags)\n  return new Renderer(tokens, options)\n}\n","import { Renderer, ResolveFn, ResolveFnAsync } from './renderer'\nimport { Scope } from './get'\nimport { compile, ICompileOptions } from './compile'\n\n/**\n * Replaces every {{varName}} inside the template with values from the scope\n * parameter.\n *\n * @param template The template containing one or more {{varName}} as\n * placeholders for values from the `scope` parameter.\n * @param scope An object containing values for variable names from the the\n * template. If it's omitted, we default to an empty object.\n * Since functions are objects in javascript, the `scope` can technically be a\n * function too but it won't be called. It'll be treated as an object and its\n * properties will be used for the lookup.\n * @param options same options as the [[compile]] function\n * @throws any error that [[compile]] or [[Renderer.render]] may throw\n * @returns Template where its variable names replaced with\n * corresponding values.\n */\nexport function render(\n  template: string,\n  scope?: Scope,\n  options?: ICompileOptions\n) {\n  const renderer: Renderer = compile(template, options)\n  return renderer.render(scope)\n}\n\n/**\n * Same as [[render]] but accepts a resolver function which will be responsible\n * for returning a value for every varName.\n * @throws any error that [[compile]] or [[Renderer.renderFn]] may throw\n */\nexport function renderFn(\n  template: string,\n  resolveFn: ResolveFn,\n  scope?: Scope,\n  options?: ICompileOptions\n) {\n  const renderer: Renderer = compile(template, options)\n  return renderer.renderFn(resolveFn, scope)\n}\n\n/**\n * Same as [[renderFn]] but only works with asynchronous resolver functions\n * (a function that returns a promise instead of the value).\n * @throws any error that [[compile]] or [[Renderer.renderFnAsync]] may throw\n */\nexport function renderFnAsync(\n  template: string,\n  resolveFnAsync: ResolveFnAsync,\n  scope?: Scope,\n  options?: ICompileOptions\n) {\n  const renderer: Renderer = compile(template, options)\n  return renderer.renderFnAsync(resolveFnAsync, scope)\n}\n"],"names":[],"mappings":"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"}