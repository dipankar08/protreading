{"version":3,"file":"micromustache.umd.min.js","sources":["../src/topath.ts","../src/get.ts","../src/renderer.ts","../src/tokenize.ts","../src/compile.ts","../src/render.ts"],"sourcesContent":["export type PropNames = string[]\n\n/**\n * The number of different varNames that will be cached.\n * If a varName is cached, the actual parsing algorithm will not be called\n * which significantly improves performance.\n * However, this cache is size-limited to prevent degrading the user's software\n * over a period of time.\n * If the cache is full, we start removing older varNames one at a time.\n */\nconst cacheSize = 100\nconst quoteChars = '\\'\"`'\n\n/**\n * @ignore\n */\nexport class Cache<T> {\n  private map: {\n    [varName: string]: T\n  }\n\n  private cachedKeys: string[]\n  private oldestIndex: number\n\n  constructor(private size: number) {\n    this.reset()\n  }\n\n  public reset() {\n    this.oldestIndex = 0\n    this.map = {}\n    this.cachedKeys = new Array(this.size)\n  }\n\n  public get(key: string): T {\n    return this.map[key]\n  }\n\n  public set(key: string, value: T) {\n    this.map[key] = value\n    const oldestKey = this.cachedKeys[this.oldestIndex]\n    if (oldestKey !== undefined) {\n      delete this.map[oldestKey]\n    }\n    this.cachedKeys[this.oldestIndex] = key\n    this.oldestIndex++\n    this.oldestIndex %= this.size\n  }\n}\n\nconst cache = new Cache<PropNames>(cacheSize)\n\n/**\n * Removes the quotes from a string and returns it.\n * @param propName an string with quotations\n * @throws `SyntaxError` if the quotation symbols don't match or one is missing\n * @returns the input with its quotes removed\n */\nfunction propBetweenBrackets(propName: string): string {\n  // in our algorithms key is always a string and never only a string of spaces\n  const firstChar = propName.charAt(0)\n  const lastChar = propName.substr(-1)\n  if (quoteChars.includes(firstChar) || quoteChars.includes(lastChar)) {\n    if (propName.length < 2 || firstChar !== lastChar) {\n      throw new SyntaxError('Mismatching string quotation: ' + propName)\n    }\n    return propName.substring(1, propName.length - 1)\n  }\n\n  if (propName.includes('[')) {\n    throw new SyntaxError('Missing ] in varName ' + propName)\n  }\n\n  // Normalize leading plus from numerical indices\n  if (firstChar === '+') {\n    return propName.substr(1)\n  }\n\n  return propName\n}\n\nfunction pushPropName(propNames: string[], propName: string, preDot: boolean) {\n  let pName = propName.trim()\n  if (pName === '') {\n    return propNames\n  }\n\n  if (pName.startsWith('.')) {\n    if (preDot) {\n      pName = pName.substr(1).trim()\n      if (pName === '') {\n        return propNames\n      }\n    } else {\n      throw new SyntaxError('Unexpected . at the start of \"' + propName + '\"')\n    }\n  } else if (preDot) {\n    throw new SyntaxError('Missing . at the start of \"' + propName + '\"')\n  }\n\n  if (pName.endsWith('.')) {\n    throw new SyntaxError('Unexpected \".\" at the end of \"' + propName + '\"')\n  }\n\n  const propNameParts = pName.split('.')\n  for (const propNamePart of propNameParts) {\n    const trimmedPropName = propNamePart.trim()\n    if (trimmedPropName === '') {\n      throw new SyntaxError('Empty prop name when parsing \"' + propName + '\"')\n    }\n    propNames.push(trimmedPropName)\n  }\n\n  return propNames\n}\n\n/**\n * Breaks a variable name to an array of strings that can be used to get a\n * particular value from an object\n * @param varName - the variable name as it occurs in the template.\n * For example `a[\"b\"].c`\n * @throws `TypeError` if the varName is not a string\n * @throws `SyntaxError` if the varName syntax has a problem\n * @returns - an array of property names that can be used to get a particular\n * value.\n * For example `['a', 'b', 'c']`\n */\nexport function toPath(varName: string): PropNames {\n  if (typeof varName !== 'string') {\n    throw new TypeError('Expected string but Got ' + varName)\n  }\n\n  let openBracketIndex: number\n  let closeBracketIndex: number = 0\n  let beforeBracket: string\n  let propName: string\n  let preDot = false\n  const propNames: PropNames = []\n\n  for (\n    let currentIndex = 0;\n    currentIndex < varName.length;\n    currentIndex = closeBracketIndex\n  ) {\n    openBracketIndex = varName.indexOf('[', currentIndex)\n    if (openBracketIndex === -1) {\n      break\n    }\n\n    closeBracketIndex = varName.indexOf(']', openBracketIndex)\n    if (closeBracketIndex === -1) {\n      throw new SyntaxError('Missing ] in varName ' + varName)\n    }\n\n    propName = varName.substring(openBracketIndex + 1, closeBracketIndex).trim()\n\n    if (propName.length === 0) {\n      throw new SyntaxError('Unexpected token ]')\n    }\n\n    closeBracketIndex++\n    beforeBracket = varName.substring(currentIndex, openBracketIndex)\n    pushPropName(propNames, beforeBracket, preDot)\n\n    propNames.push(propBetweenBrackets(propName))\n    preDot = true\n  }\n\n  const rest = varName.substring(closeBracketIndex)\n  return pushPropName(propNames, rest, preDot)\n}\n\n/**\n * This is just a faster version of `toPath()`\n */\nfunction toPathCached(varName: string): PropNames {\n  let result = cache.get(varName)\n  if (result === undefined) {\n    result = toPath(varName)\n    cache.set(varName, result)\n  }\n  return result\n}\n\ntoPath.cached = toPathCached\n","import { toPath, PropNames } from './topath'\n\n// tslint:disable-next-line ban-types\nexport type Scope = {} | Function\n\n/**\n * Checks if the provided value can be used as a scope, that is a non-null\n * object or a function.\n * @param val the value that is supposed to be tested\n */\nfunction isValidScope(val: any): val is Scope {\n  if (val) {\n    // At this point `null` is filtered out\n    const type = typeof val\n    return type === 'object' || type === 'function'\n  }\n  return false\n}\n\n/**\n * Similar to lodash `_.get()`\n *\n * Differences with JavaScript:\n * No support for keys that include `[` or `]`.\n * No support for keys that include `'` or `\"` or `.\n * `foo[bar]` is allowed while JavaScript treats `bar` as a variable and tries\n * to lookup its value or throws a `ReferenceError` if there is no variable\n * called `bar`.\n * If it cannot find a value in the specified path, it may return undefined or\n * throw an error depending on the value of the `propExists` param.\n * @param scope an object to resolve value from\n * @param varNameOrPropNames the variable name string or an array of property\n * names (as returned by `toPath()`)\n * @param propExists claiming that the varName is exists in the scope.\n * It defaults to false which means we don't throw an error (like Mustachejs).\n * @throws `SyntaxError` if the varName string cannot be parsed\n * @throws `ReferenceError` if the scope does not contain the requested key\n * but the `propExists` is set to a truthy value\n * @returns the value or undefined. If path or scope are undefined or scope is\n * null the result is always undefined.\n */\nexport function get(\n  scope: Scope,\n  varNameOrPropNames: PropNames | string,\n  propExists?: boolean\n): any {\n  const propNames = Array.isArray(varNameOrPropNames)\n    ? varNameOrPropNames\n    : toPath.cached(varNameOrPropNames)\n\n  let currentScope = scope\n  for (const propName of propNames) {\n    if (isValidScope(currentScope)) {\n      // @ts-ignore\n      currentScope = currentScope[propName]\n    } else if (propExists) {\n      throw new ReferenceError(\n        propName +\n          ' is not defined in the scope (' +\n          scope +\n          '). Parsed path: ' +\n          propNames\n      )\n    } else {\n      return\n    }\n  }\n  return currentScope\n}\n","import { Scope, get } from './get'\nimport { PropNames, toPath } from './topath'\nimport { ITokens } from './tokenize'\n\n/**\n * The options passed to Renderer's constructor\n */\nexport interface IRendererOptions {\n  /**\n   * When set to a truthy value, rendering literally puts a 'null' or\n   * 'undefined' for values that are `null` or `undefined`.\n   * By default it swallows those values to be compatible with Mustache.\n   */\n  readonly explicit?: boolean\n  /**\n   * When set to a truthy value, we throw a ReferenceError for invalid varNames.\n   * Invalid varNames are the ones that do not exist in the scope.\n   * In that case the value for the varNames will be assumed an empty string.\n   * By default we throw a ReferenceError to be compatible with how JavaScript\n   * threats such invalid reference.\n   * If a value does not exist in the scope, two things can happen:\n   * - if `propsExist` is truthy, the value will be assumed empty string\n   * - if `propsExist` is falsy, a ReferenceError will be thrown\n   */\n  readonly propsExist?: boolean\n  /** when set to a truthy value, validates the variable names */\n  readonly validateVarNames?: boolean\n}\n\nconst defaultRendererOptions: IRendererOptions = {}\n\n/**\n * The callback for resolving a value (synchronous)\n * @param scope the scope object that was passed to .render() function\n * @param path variable name before being parsed.\n * @example a template that is `Hi {{a.b.c}}!` leads to `'a.b.c'` as path\n * @returns the value to be interpolated.\n */\nexport type ResolveFn = (varName: string, scope?: Scope) => any\n\n/**\n * Same as `ResolveFn` but for asynchronous functions\n */\nexport type ResolveFnAsync = (varName: string, scope?: Scope) => Promise<any>\n\n/**\n * This class does the heavy lifting of interpolation (putting the actual values\n * in the template).\n * This is created by the `.compile()` method and is used under the hood by\n * `.render()`, `renderFn()` and `renderFnAsync()` functions.\n */\nexport class Renderer {\n  /**\n   * Another cache that holds the parsed values for `toPath()` one per varName\n   */\n  private toPathCache: PropNames[]\n\n  /**\n   * Creates a new Renderer instance. This is called internally by the compiler.\n   * @param tokens - the result of the `.tokenize()` function\n   * @param options - some options for customizing the rendering process\n   * @throws `TypeError` if the token is invalid\n   */\n  constructor(\n    private readonly tokens: ITokens,\n    private readonly options: IRendererOptions = defaultRendererOptions\n  ) {\n    if (\n      tokens === null ||\n      typeof tokens !== 'object' ||\n      !Array.isArray(tokens.strings) ||\n      !Array.isArray(tokens.varNames) ||\n      tokens.strings.length !== tokens.varNames.length + 1\n    ) {\n      throw new TypeError('Invalid tokens object ' + tokens)\n    }\n    if (options.validateVarNames) {\n      // trying to initialize toPathCache parses them which is also validation\n      this.cacheParsedPaths()\n    }\n  }\n\n  /**\n   * This function is called internally for filling in the `toPathCache` cache.\n   * If the `validateVarNames` option for the constructor is set to a truthy\n   * value, this function is called immediately which leads to a validation as\n   * well because it throws an error if it cannot parse variable names.\n   */\n  private cacheParsedPaths() {\n    const { varNames } = this.tokens\n    if (this.toPathCache === undefined) {\n      this.toPathCache = new Array(varNames.length)\n      for (let i = 0; i < varNames.length; i++) {\n        this.toPathCache[i] = toPath.cached(varNames[i])\n      }\n    }\n  }\n\n  /**\n   * Replaces every {{varName}} inside the template with values from the scope\n   * parameter.\n   *\n   * @param template The template containing one or more {{varName}} as\n   * placeholders for values from the `scope` parameter.\n   * @param scope An object containing values for variable names from the the\n   * template. If it's omitted, we default to an empty object.\n   */\n  public render = (scope: Scope = {}): string => {\n    const { varNames } = this.tokens\n    const { length } = varNames\n    this.cacheParsedPaths()\n    const values = new Array(length)\n    for (let i = 0; i < length; i++) {\n      values[i] = get(scope, this.toPathCache[i], this.options.propsExist)\n    }\n    return this.stringify(values)\n  }\n\n  /**\n   * Same as [[render]] but accepts a resolver function which will be\n   * responsible for returning a value for every varName.\n   */\n  public renderFn = (resolveFn: ResolveFn, scope: Scope = {}): string => {\n    const values = this.resolveVarNames(resolveFn, scope)\n    return this.stringify(values)\n  }\n\n  /**\n   * Same as [[render]] but accepts a resolver function which will be responsible\n   * for returning promise that resolves to a value for every varName.\n   */\n  public renderFnAsync = (\n    resolveFnAsync: ResolveFnAsync,\n    scope: Scope = {}\n  ): Promise<string> => {\n    return Promise.all(this.resolveVarNames(resolveFnAsync, scope)).then(\n      values => this.stringify(values)\n    )\n  }\n\n  private resolveVarNames(resolveFn: ResolveFn, scope: Scope = {}): any[] {\n    const { varNames } = this.tokens\n    if (typeof resolveFn !== 'function') {\n      throw new TypeError('Expected a resolver function but got ' + resolveFn)\n    }\n\n    const { length } = varNames\n    const values = new Array(length)\n    for (let i = 0; i < length; i++) {\n      values[i] = resolveFn.call(null, varNames[i], scope)\n    }\n    return values\n  }\n\n  /**\n   * Puts the resolved `values` into the rest of the template (`strings`) and\n   * returns the final result that'll be returned from `render()`, `renderFn()`\n   * and `renderFnAsync()` functions.\n   */\n  private stringify(values: any[]): string {\n    const { strings } = this.tokens\n    const { explicit } = this.options\n    let ret = ''\n    const { length } = values\n    for (let i = 0; i < length; i++) {\n      ret += strings[i]\n      const value = values[i]\n      if (explicit || (value !== null && value !== undefined)) {\n        ret += value\n      }\n    }\n\n    ret += strings[length]\n    return ret\n  }\n}\n","export interface ITokens {\n  /** An array of constant strings */\n  readonly strings: string[]\n  /** An array of variable names */\n  readonly varNames: string[]\n}\n\n/**\n * An array of two strings specifying the opening and closing tags that mark\n * the start and end of a variable name in the template.\n * It defaults to `['{{', '}}']`\n */\nexport type TokenizeOptions = [string, string]\nconst defaultTokenizeOptions: TokenizeOptions = ['{{', '}}']\n\n/**\n * Parse a template and returns the tokens in an object.\n *\n * @throws `TypeError` if there's an issue with its inputs\n * @throws `SyntaxError` if there's an issue with the template\n *\n * @param template the template\n * @param openSym the string that marks the start of a variable name\n * @param closeSym the string that marks the start of a variable name\n * @returns the resulting tokens as an object that has strings and variable names\n */\nexport function tokenize(\n  template: string,\n  options: TokenizeOptions = defaultTokenizeOptions\n): ITokens {\n  if (!Array.isArray(options)) {\n    throw Error(\n      `Tags should be an array. Got ${options}`\n    )\n  }\n\n  if (options.length !== 2) {\n    throw new TypeError(`The tags array should contain exactly two elements, got ${options.length}`)\n  }\n\n  const [openSym, closeSym] = options\n  if (typeof openSym !== 'string' || openSym.length === 0) {\n    throw new TypeError(`openSym should be a non-empty string. Got ${openSym}`)\n  }\n  if (typeof closeSym !== 'string' || closeSym.length === 0) {\n    throw new TypeError(`closeSym should be a non-empty string. Got ${closeSym}`)\n  }\n  \n  const maxVarNameLength = 1000\n\n  if (\n    typeof openSym !== 'string' ||\n    typeof closeSym !== 'string' ||\n    openSym.length === 0 ||\n    closeSym.length === 0 ||\n    openSym === closeSym\n  ) {\n    throw new TypeError(\n      'The tags array should have two distinct non-empty strings. Got ' +\n        options.join()\n    )\n  }\n\n  const openSymLen = openSym.length\n  const closeSymLen = closeSym.length\n\n  let openIndex: number\n  let closeIndex: number = 0\n  let varName: string\n  const strings: string[] = []\n  const varNames: string[] = []\n  let currentIndex = 0\n\n  while (currentIndex < template.length) {\n    openIndex = template.indexOf(openSym, currentIndex)\n    if (openIndex === -1) {\n      break\n    }\n\n    closeIndex = template.indexOf(closeSym, openIndex)\n    if (closeIndex === -1) {\n      throw new SyntaxError(\n        'Missing \"' + closeSym + '\" in the template expression ' + template\n      )\n    }\n\n    const varNameStartIndex = openIndex + openSymLen\n    const varNameLength = closeIndex - varNameStartIndex\n    if (varNameLength > maxVarNameLength) {\n      throw new SyntaxError(\n        'Variable name cannot be longer than ' +\n          maxVarNameLength +\n          ' but at position ' +\n          openIndex +\n          ' it is \"' +\n          varNameLength +\n          '\"'\n      )\n    }\n\n    varName = template.substr(varNameStartIndex, varNameLength).trim()\n\n    if (varName.length === 0) {\n      throw new SyntaxError(\n        'Unexpected \"' + closeSym + '\" tag found at position ' + openIndex\n      )\n    }\n\n    if (varName.length >= maxVarNameLength) {\n      throw new SyntaxError(`The variable name is longer than expected. Max: ${maxVarNameLength}, Got: ${varName.length}`)\n    }\n\n    if (varName.includes(openSym)) {\n      throw new SyntaxError(\n        'Variable names cannot have \"' +\n          openSym +\n          '\". But at position ' +\n          openIndex +\n          ' got \"' +\n          varName +\n          '\"'\n      )\n    }\n\n    varNames.push(varName)\n\n    closeIndex += closeSymLen\n    strings.push(template.substring(currentIndex, openIndex))\n    currentIndex = closeIndex\n  }\n\n  strings.push(template.substring(closeIndex))\n\n  return { strings, varNames }\n}\n","import { Renderer, IRendererOptions } from './renderer'\nimport { tokenize, TokenizeOptions } from './tokenize'\n\n/**\n * The options that customize the tokenization of the template and the renderer\n * object that is returned\n */\nexport interface ICompileOptions extends IRendererOptions {\n  /**\n   * The string symbols that mark the opening and closing of a variable name in\n   * the template.\n   * It defaults to `['{{', '}}']`\n   */\n  readonly tags?: TokenizeOptions\n}\n\nconst defaultCompileOptions: ICompileOptions = {}\n\n/**\n * Compiles a template and returns an object with functions that render it.\n * Compilation makes repeated render calls more optimized by parsing the\n * template only once and reusing the results.\n * As a result, rendering gets 3-5x faster.\n * Caching is stored in the resulting object, so if you free up all the\n * references to that object, the caches will be garbage collected.\n *\n * @param template same as the template parameter to .render()\n * @param options some options for customizing the compilation\n * @throws `TypeError` if the template is not a string\n * @throws `TypeError` if the options is set but is not an object\n * @throws any error that [[tokenize]] or [[Renderer.constructor]] may throw\n * @returns an object with some methods that can do the actual rendering\n */\nexport function compile(\n  template: string,\n  options: ICompileOptions = defaultCompileOptions\n): Renderer {\n  if (typeof template !== 'string') {\n    throw new TypeError(\n      'The template parameter must be a string. Got ' + template\n    )\n  }\n\n  if (options === null || typeof options !== 'object') {\n    throw new TypeError(\n      'The compiler options should be an object. Got ' + options\n    )\n  }\n\n  const tokens = tokenize(template, options.tags)\n  return new Renderer(tokens, options)\n}\n","import { Renderer, ResolveFn, ResolveFnAsync } from './renderer'\nimport { Scope } from './get'\nimport { compile, ICompileOptions } from './compile'\n\n/**\n * Replaces every {{varName}} inside the template with values from the scope\n * parameter.\n *\n * @param template The template containing one or more {{varName}} as\n * placeholders for values from the `scope` parameter.\n * @param scope An object containing values for variable names from the the\n * template. If it's omitted, we default to an empty object.\n * Since functions are objects in javascript, the `scope` can technically be a\n * function too but it won't be called. It'll be treated as an object and its\n * properties will be used for the lookup.\n * @param options same options as the [[compile]] function\n * @throws any error that [[compile]] or [[Renderer.render]] may throw\n * @returns Template where its variable names replaced with\n * corresponding values.\n */\nexport function render(\n  template: string,\n  scope?: Scope,\n  options?: ICompileOptions\n) {\n  const renderer: Renderer = compile(template, options)\n  return renderer.render(scope)\n}\n\n/**\n * Same as [[render]] but accepts a resolver function which will be responsible\n * for returning a value for every varName.\n * @throws any error that [[compile]] or [[Renderer.renderFn]] may throw\n */\nexport function renderFn(\n  template: string,\n  resolveFn: ResolveFn,\n  scope?: Scope,\n  options?: ICompileOptions\n) {\n  const renderer: Renderer = compile(template, options)\n  return renderer.renderFn(resolveFn, scope)\n}\n\n/**\n * Same as [[renderFn]] but only works with asynchronous resolver functions\n * (a function that returns a promise instead of the value).\n * @throws any error that [[compile]] or [[Renderer.renderFnAsync]] may throw\n */\nexport function renderFnAsync(\n  template: string,\n  resolveFnAsync: ResolveFnAsync,\n  scope?: Scope,\n  options?: ICompileOptions\n) {\n  const renderer: Renderer = compile(template, options)\n  return renderer.renderFnAsync(resolveFnAsync, scope)\n}\n"],"names":[],"mappings":"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"}